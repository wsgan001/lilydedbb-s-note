# CCF 201403

## CCF201403-1 相反数

试题编号：	201403-1

试题名称：	相反数

时间限制：	1.0s

内存限制：	256.0MB

**问题描述**：有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。

**输入格式**

第一行包含一个正整数 N。(1 ≤ N ≤ 500)。

第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。

**输出格式**

只输出一个整数,即这 N 个数中包含多少对相反数。

**样例输入**

```
5
1 2 3 -1 -2
```

**样例输出**

```
2
```

```c
#include <iostream>
#include <map>
using namespace std;

int main () {

	int n, num, count = 0;
	map <int, int> m;
	cin >> n;
	while (n--) {
		cin >> num;
		if (m.find(-num) == m.end()) m[num]++;
		else count++;
	}
	cout << count << endl;

	return 0;
}
```


------


## CCF201403-2 窗口

试题编号：	201403-2

试题名称：	窗口

时间限制：	1.0s

内存限制：	256.0MB

问题描述：在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。

当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。

现在我们希望你写一个程序模拟点击窗口的过程。

输入格式

输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10)

接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 < x2,y1 2。

接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。

题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和　　1439。

输出格式

输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出"IGNORED"(不含双引号)。

样例输入

```
3 4
0 0 4 4
1 1 5 5
2 2 6 6
1 1
0 0
4 4
0 5
```

样例输出

```
2
1
1
IGNORED
```

样例说明

第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。

第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。

第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。

最后点击的 (0, 5) 不属于任何窗口。

```c
#include <iostream>
#include <stack>
using namespace std;

struct Window {
	int id;
	int x1, y1, x2, y2;
	Window(int id, int x1, int y1, int x2, int y2): id(id), x1(x1), y1(y1), x2(x2), y2(y2) {};
};

stack<Window> q;

int click (int x, int y) {
	stack<Window> temp;
	Window w = q.top();
	int id = -1;
	while (!q.empty()) {
		w = q.top();
		q.pop();
		if (w.x1 <= x && w.y1 <= y && x <= w.x2 && y <= w.y2) {
			id = w.id;
			break;
		} else {
			temp.push(w);
		}
	}
	while (!temp.empty()) {
		q.push(temp.top());
		temp.pop();
	}
	q.push(w);
	return id;
}

int main () {

	freopen("data2.txt", "r", stdin);
	int id = 1, n, m, x1, y1, x2, y2, x, y;
	cin >> n >> m;
	while (n--) {
		cin >> x1 >> y1 >> x2 >> y2;
		q.push(Window(id++, x1, y1, x2, y2));
	}
	while (m--) {
		cin >> x >> y;
		int id = click(x, y);
		if (id == -1) cout << "IGNORED" << endl;
		else cout << id << endl;
	}

	return 0;
}
```


------


## CCF201403-3 命令行选项

试题编号：	201403-3

试题名称：	命令行选项

时间限制：	1.0s

内存限制：	256.0MB

**问题描述**：请你写一个命令行分析程序,用以分析给定的命令行里包含哪些选项。每个命令行由若干个字符串组成,它们之间恰好由一个空格分隔。这些字符串中的第一个为该命令行工具的名字,由小写字母组成,你的程序不用对它进行处理。在工具名字之后可能会包含若干选项,然后可能会包含一 些不是选项的参数。

选项有两类:带参数的选项和不带参数的选项。一个合法的无参数选项的形式是一个减号后面跟单个小写字母,如"-a" 或"-b"。而带参数选项则由两个由空格分隔的字符串构成,前者的格式要求与无参数选项相同,后者则是该选项的参数,是由小写字母,数字和减号组成的非空字符串。

该命令行工具的作者提供给你一个格式字符串以指定他的命令行工具需要接受哪些选项。这个字符串由若干小写字母和冒号组成,其中的每个小写字母表示一个该程序接受的选项。如果该小写字母后面紧跟了一个冒号,它就表示一个带参数的选项,否则则为不带参数的选项。例如, "ab:m:" 表示该程序接受三种选项,即"-a"(不带参数),"-b"(带参数), 以及"-m"(带参数)。

命令行工具的作者准备了若干条命令行用以测试你的程序。对于每个命令行,你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项,又不是某个合法选项的参数时,分析就停止。命令行剩余的未分析部分不构成该命令的选项,因此你的程序应当忽略它们。

**输入格式**

输入的第一行是一个格式字符串,它至少包含一个字符,且长度不超过 52。格式字符串只包含小写字母和冒号,保证每个小写字母至多出现一次,不会有两个相邻的冒号,也不会以冒号开头。

输入的第二行是一个正整数 N(1 ≤ N ≤ 20),表示你需要处理的命令行的个数。

接下来有 N 行,每行是一个待处理的命令行,它包括不超过 256 个字符。该命令行一定是若干个由单个空格分隔的字符串构成,每个字符串里只包含小写字母,数字和减号。

**输出格式**

输出有 N 行。其中第 i 行以"Case i:" 开始,然后应当有恰好一个空格,然后应当按照字母升序输出该命令行中用到的所有选项的名称,对于带参数的选项,在输出它的名称之后还要输出它的参数。如果一个选项在命令行中出现了多次,只输出一次。如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。

**样例输入**

```
albw:x
4
ls -a -l -a documents -b
ls
ls -w 10 -x -w 15
ls -a -b -c -d -e -l
```

**样例输出**

```
Case 1: -a -l
Case 2:
Case 3: -w 15 -x
Case 4: -a -b
```

```c
#include <iostream>
#include <string>
#include <map>
using namespace std;
map<char, bool> flag;

int main () {

	freopen("data3.txt", "r", stdin);
	int n;
	string vars, line;
	cin >> vars;
	for (int i = 0; i < vars.length(); i++) {
		if (i + 1 < vars.length() && vars[i + 1] == ':') flag[vars[i]] = true;
		else flag[vars[i]] = false;
	}
	cin >> n;
	getline(cin, line);
	for (int i = 1; i <= n; i++) {
		getline(cin, line);
		map<char, string> m;
		int pos = line.find(" ");
		while (pos != string::npos) {
			string str = line.substr(0, pos);
			if (str[0] == '-') {
				char c = str[1];
				if (flag.find(c) != flag.end()) {
					line.erase(0, pos + 1);
					pos = line.find(" ");
					if (flag[c]) {
						string str = line.substr(0, pos);
						line.erase(0, pos + 1);
						m[c] = str;
					} else {
						m[c] = "";
					}
				} else {
					break;
				}
			} else {
				line.erase(0, pos + 1);
				pos = line.find(" ");
			}
		}
		cout << "Case " << i << ": ";
		for (map<char, string>::iterator it = m.begin(); it != m.end(); it++) {
			cout << "-" << it->first << " ";
			if (m[it->first].length() > 0)
				cout << m[it->first] << " ";
		}
		cout << endl;
	}

	return 0;
}
```


------


## CCF201403-4 无线网络

试题编号：	201403-4

试题名称：	无线网络

时间限制：	1.0s

内存限制：	256.0MB

**问题描述**：目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。

除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。

你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?

**输入格式**

第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。

接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。

接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。

输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。

**输出格式**

输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。

**样例输入**

```
5 3 1 3
0 0
5 5
0 3
0 5
3 5
3 3
4 4
3 0
```

**样例输出**

```
2
```

```c

```
