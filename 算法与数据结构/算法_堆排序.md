## 堆

堆，是一种完全二叉树，分为```最大堆```和```最小堆```（或者叫```“大根堆”``` ```“小根堆”```）。
最大堆即：每个父节点元素都大于等于其所有子节点元素。最小堆同理。

堆排序的第一步便是构造堆。构造堆有两个重要方法，即```sink（下沉）```和```swim（上浮）```。


### ```sink``` & ```swim```

假设目前又一个有序的最大堆，然后在index处插入一个元素，堆变的无序，为了使堆恢复有序，就要用到```sink```和```swim```方法，代码实现如下：

【声明】这里假设堆顶为0，所以第```k```个节点的子节点为```2 * k + 1```和```2 * k + 2```，父节点为```(k % 2 == 0) ? ((k - 1) / 2) : (k / 2)```
```c
// 堆排序辅助方法————下沉（小元素下沉）
void sink(int *arr, int index, int len){
    int i;
    // index 的子节点为 (2 * index + 1) 和 (2 * index + 2)
    while(2 * index + 1 <= len - 1){
        i = 2 * index + 1;
        // 和最大的子节点交换
        if((i + 1 <= len - 1) && (arr[i] <= arr[i + 1]))
            i++;
        if(arr[index] >= arr[i])
            break;
        exchange(arr, index, i);
        index = i;
    }
}
```
方法```sink```的主要思想就是，比较父节点和子节点，并把该元素和最大的子节点交换，一直```“沉”```到适当的位置，这里是最大堆，所以把小元素```“下沉”```。
```c
// 堆排序辅助方法————上升（大元素上升）
void swim(int *arr, int index, int len){
    int i;
    while (index > 0) {
        i = (index % 2 == 0) ? ((index - 1) / 2) : (index / 2); // 父节点
        if(arr[index] <= arr[i])
            break;
        exchange(arr, index, i);
        index = i;
    }
}
```
而```swim```则和```sink```相反，比较子节点和父节点，一直```“浮”```到适当的位置，这里是最大堆，所以把大元素```“上浮”```。


### 构造堆

构造堆即通过```sink```和```swim```方法。

【注意】构造堆时，如果用```sink```法，就要从数组的一半位置向前迭代；如果用```swim```法就要从堆第二层（即第二个元素）开始向后迭代。

```c
// sink构建最大堆
for(int i = len / 2 - 1; i >= 0; i--)
    sink(arr, i, len);
```
```c
// swim构建最大堆
for(int i = 1; i < len; i++)
    swim(arr, i, len);
```


### 堆排序

堆排序第一步即是构造堆。构造堆后，即从最后一个元素开始，交换堆顶和堆的最后一个元素，因为是最大堆，所以此时堆的最后一个元素应为最大数，然后除去该数，即堆的大小减一，把堆顶```sink```下来，这样大小减一之后的堆就又变为有序的了。代码实现如下：
```c
// 堆排序
void heapSort(int *arr, int len){

    // sink构建最大堆
    for(int i = len / 2 - 1; i >= 0; i--)
        sink(arr, i, len);

    // 下沉排序
    for(int i = len - 1; i >= 0; i--){
        exchange(arr, 0, i); // 交换堆顶和最后一位，最后一位即为最大数
        sink(arr, 0, i); // 将堆的大小减一，然后将换到堆顶的数”沉“下去
    }
}
```